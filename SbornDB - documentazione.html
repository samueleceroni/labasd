<html><head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>SbornDB - documentazione</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
  -webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
  table, pre {
    page-break-inside: avoid;
  }
  pre {
    word-wrap: break-word;
  }
}
</style>

<style type="text/css">
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
  color: black;
  background: none;
  text-shadow: 0 1px white;
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
  text-shadow: none;
  background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
  text-shadow: none;
  background: #b3d4fc;
}

@media print {
  code[class*="language-"],
  pre[class*="language-"] {
    text-shadow: none;
  }
}

/* Code blocks */
pre[class*="language-"] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
  background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: slategray;
}

.token.punctuation {
  color: #999;
}

.namespace {
  opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
  color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: #a67f59;
  background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
  color: #07a;
}

.token.function {
  color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
  color: #e90;
}

.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}

.token.entity {
  cursor: help;
}
</style>

<style type="text/css">
div.prism-show-language {
  position: relative;
}

div.prism-show-language > div.prism-show-language-label {
  color: black;
  background-color: #CFCFCF;
  display: inline-block;
  position: absolute;
  bottom: auto;
  left: auto;
  top: 0;
  right: 0;
  width: auto;
  height: auto;
  font-size: 0.9em;
  border-radius: 0 0 0 5px;
  padding: 0 0.5em;
  text-shadow: none;
  z-index: 1;
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  -webkit-transform: none;
  -moz-transform: none;
  -ms-transform: none;
  -o-transform: none;
  transform: none;
}
</style>


</head>

<body>

<h1 id="toc_0">SbornDB – documentazione</h1>

<hr>

<h1 id="toc_1">Dati dei componenti del gruppo</h1>

<p>Consegna: 5 Settembre 2018</p>

<table>
<thead>
<tr>
<th style="text-align: center">Studente</th>
<th style="text-align: center">Matricola</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">Samuele Ceroni</td>
<td style="text-align: center">0000825238</td>
</tr>
<tr>
<td style="text-align: center">Giacomo Aloisi</td>
<td style="text-align: center">0000832933</td>
</tr>
<tr>
<td style="text-align: center">Ugo Baroncini</td>
<td style="text-align: center">0000842092</td>
</tr>
</tbody>
</table>

<p>Per lo sviluppo abbiamo usato:</p>

<ul>
<li>IDE: <code>Sublime Text 3</code></li>
<li>Compilatore: <code>gcc</code></li>
<li>Sistemi Operativi: <code>Mac OS X e Linux Debian</code></li>
</ul>

<p>A sviluppo completato abbiamo fatto il porting del progetto su Visual Studio 2015 su Windows 10 per ulteriori test.
Il lavoro di gruppo è stato gestito con un repository <code>git</code> condiviso tramite GitHub.</p>

<hr>

<h1 id="toc_2">Indice</h1>

<ol>
<li><strong>Premessa</strong></li>
<li><strong>Gestione della memoria</strong>

<ul>
<li>2.1 Premessa</li>
<li>2.2 Assunzioni</li>
<li>2.3 Scopo</li>
<li>2.4 Definizione delle caratteristiche</li>
<li>2.5 Descrizione

<ul>
<li><em>2.5.1 Perchè un limite di memoria</em></li>
<li><em>2.5.2 Modalità di implementazione</em></li>
<li><em>2.5.3 Operazioni nell'heap a seguito delle query</em></li>
<li><em>2.5.4 Update Dinamico con complessità logaritmica</em></li>
</ul></li>
</ul></li>
<li><strong>Strutture dati</strong>

<ul>
<li>3.1 Linked List</li>
<li>3.2 Red-Black Tree

<ul>
<li><em>3.2.1 struct RBT</em></li>
<li><em>3.2.2 struct RBTNode</em></li>
<li><em>3.2.3 Uso</em></li>
</ul></li>
<li>3.3 Heap con Update Dinamico</li>
<li>3.4 Strutture

<ul>
<li><em>3.4.1 Struttura TableDB</em></li>
<li><em>3.4.2 Struttura ParseResult</em></li>
<li><em>3.4.3 Struttura QueryResultElement</em></li>
</ul></li>
</ul></li>
<li><strong>Corpo centrale</strong>

<ul>
<li>4.1 Inizializzazione</li>
<li>4.2 Parsing</li>
<li>4.3 Recupero della tabella</li>
<li>4.4 Esecuzione Query

<ul>
<li><em>4.4.1 Fase di Controllo</em></li>
<li><em>4.4.2 Creazione</em></li>
<li><em>4.4.3 Inserimento</em></li>
<li><em>4.4.4 Selezione</em></li>
</ul></li>
<li>4.5 Fase di Liberazione della memoria</li>
</ul></li>
<li><strong>Parser</strong></li>
<li><strong>Costi Computazionali</strong> 

<ul>
<li>6.1 CREATE TABLE</li>
<li>6.2 INSERT INTO</li>
<li>6.3 SELECT

<ul>
<li>6.3.1 Select senza filtri</li>
<li>6.3.2 Select Order By</li>
<li>6.3.3 Select Group By</li>
<li>6.3.4 Select Where</li>
</ul></li>
<li>Caricamento ed eliminazione tabelle dalla RAM<br></li>
</ul></li>
<li><strong>Riferimenti Esterni</strong></li>
</ol>

<hr>

<h1 id="toc_3" style="
    margin-top:  600px;
">1. Premessa</h1>

<p>In questo file sono racchiuse tutte le specifiche sul funzionamento del database, sui suoi costi in termini di velocità e di memoria.
Il progetto è diviso in: gestione della memoria, strutture dati, corpo centrale e parser.
Ogni parte verrà analizzata nel dettaglio e nella sezione finale verranni discussi i costi computazionali di tempo e spazio.
È stato pensato di inserire nel file header del progetto solo le funzioni esterne, ovvero quelle che servono alle diverse parti del progetto per dialogare tra loro, mentre le funzioni secondarie, quelle interne, sono dichiarate nelle prime righe del file sorgente. È stato pernsato di fare come quando si lavora con diversi file, per rendere le funzioni "private" o "pubbliche", per nostra chiarezza mentale e di contenuti.</p>

<hr>

<h1 id="toc_4">2. Gestione della memoria</h1>

<h2 id="toc_5">2.1 Premessa</h2>

<p>Un reale database, di quelli che possiamo trovare in sistemi enterprise e di produzione, possono immagazzinare una grande quantità di dati. In fase di progettazione abbiamo deciso di emulare, per quanto possibile, le capacità di questi sistemi, cercando il miglior compromesso tra complessità di implementazione e prestazioni con dataset corposi.</p>

<h2 id="toc_6">2.2 Assunzioni</h2>

<ol>
<li> I file di testo devono mantenere la struttura indicata nelle specifiche del progetto.</li>
<li> Non si possono creare altri file su disco, per salvare dati in forma più comoda all’uso con certe strutture dati.</li>
<li> La gestione della memoria deve essere efficiente come il resto del sistema.
Il database mantiene i dati su disco secondo le specifiche del progetto, in RAM vengono usate strutture dati viste al corso per avere ottime prestazioni. </li>
</ol>

<h2 id="toc_7">2.3 Scopo</h2>

<p>Limitare l’utilizzo di RAM per mantenere alte le prestazioni di tutto il sistema, senza rallentare le query.</p>

<h2 id="toc_8">2.4 Definizione delle caratteristiche</h2>

<ol>
<li> Possibilità di definire una soglia di memoria, sopra la quale è necessario deallocare per avere altra memoria.</li>
<li> Deve permettere al database di caricare almeno una tabella per volta.</li>
<li> Migliorare il processo di allocazione e deallocazione tramite un sistema di caching basilare.</li>
</ol>

<h2 id="toc_9" style="
    margin-top:  100px;
">2.5 Descrizione</h2>

<h3 id="toc_10">2.5.1 Perchè un limite di memoria</h3>

<p>Supponendo un utilizzo con dataset grandi, un sistema di caching ben realizzato può fornire speed-up importanti, limitando i caricamenti da disco.
Se non gestito, il sistema di caching arriverebbe ad avere tutti i dati in RAM, senza caricare nulla da disco e potenzialmente rallentando l'intera macchina.
Considerando un caching completo una strada non sempre percorribile, il sistema di limitazione della memoria serve a prevenire eccessivi rallentamenti, eliminando le tabelle dalla RAM secondo un criterio temporale.
In caso di pessime prestazioni con cambi repentini di tabelle, si suggerisce di aumentare il limite di memoria (è possibile farlo manualmente modificando il parametro MEMORY_THRESHOLD, anche per testare il sistema implementato).</p>

<h3 id="toc_11">2.5.2 Modalità di implementazione</h3>

<p>Il sistema usa un heap con update dinamico per approssimare una coda di priorità con update dinamico.
La chiave dell'heap è un intero che indica l'indice dell'ultima query su quella tabella. La tabella è memorizzata come valore.
La memoria utilizzata da ogni tabella viene sommata in un contatore generale, usato per i confronti con il limite impostato.</p>

<h3 id="toc_12">2.5.3 Operazioni nell'heap a seguito delle query</h3>

<p>Ad ogni query, la chiave della tabella interessata viene aggiornata, spostando la tabella in una foglia dell'heap.
Quando la memoria raggiunge il limite impostato, il sistema procede a deallocare tabelle dalla radice dell'heap, fino a quando non c'è abbastanza spazio a disposizione, o rimane una sola tabella.</p>

<h3 id="toc_13">2.5.4 Update Dinamico con complessità logaritmica</h3>

<p>Per poter effettuare l'update dinamico sull'heap con complessità logaritmica, è necessario un riferimento reciproco tra l'elemento nell’heap e la tabella corrispondente: nel nodo dell'heap è presente un puntatore alla tabella e vice versa.
L’heap è una struttura dati vista a lezione che è stata aumentata per gestire l’update dinamico in <code>O(log n)</code>.
Per la implementazione si è preso spunto dal paper <a src="https://www.cs.tau.ac.il/~mad/publications/opodis2015-heap.pdf"><em>A Heap-Based Concurrent Priority Queue with Mutable Priorities for Faster Parallel Algorithms</em></a> redatto da O. Tamir, A. Morrison e N. Rinetzky [1], osservando in particolare la sezione numero 3 : <em>“A Sequential Heap with Mutable Priorities”</em>.</p>

<hr>

<h1 id="toc_14" style="
    margin-top: 300px;
">3. Database e Strutture dati</h1>

<p>Il database è accessibile da un unico puntatore dichiarato globale e statico. È stata fatta questa scelta in quanto si assume di lavorare sempre su un unico database, seguendo le linee guida del progetto. In questo modo si evita di appesantire lo stack di sistema a ogni chiamata di funzione. Segue uno schema grafico della sua struttura interna e la spiegazione di ogni elemento di cui è composto.</p>

<p><img src="dataStructureScheme.png" alt="schema del database"></p>

<p>Nel database vengono utilizzate:</p>

<ol>
<li> Linked List</li>
<li> Red-Black Tree </li>
<li> Heap con Update Dinamico</li>
</ol>

<h2 id="toc_15" style="
    margin-top: 100px;
">3.1 Linked List</h2>

<p>Le linked list utilizzate sono implementate nel modo classico.</p>

<h2 id="toc_16" style="
    margin-top:  200px;
">3.2 Red-Black Tree</h2>

<p>I Red-Black Tree (d’ora in poi chiamati anche RBT) utilizzati sono stati modificati per l’applicazione specifica. L’implementazione delle funzioni core si è ispirata allo pseudo-codice presente sul libro di testo consigliato dal docente “Introduction to Algorithms” di Cormen, Leiserson, Rivest e Stein.</p>

<h3 id="toc_17">3.2.1 Struct RBT</h3>

<p>La struct utilizzata per rappresentare l’albero contiene:</p>

<ol>
<li> Puntatore alla radice <code>struct RBTNode * root</code></li>
<li> Chiave intera <code>int key</code>. Il valore della key può essere:

<ul>
<li>Key == -2 : indica che il RBT contiene tabelle</li>
<li>Key == -1 : non utilizzato, riservato dalla funzione <code>searchColumnIndex()</code></li>
<li>0 ≤ Key ≤ MAX_INT : indica che il RBT contiene puntatori a record, e il valore di key rappresenta l’indice della colonna nella tabella.</li>
</ul></li>
</ol>

<h3 id="toc_18">3.2.2 Struct RBTNode</h3>

<p>La struct utilizzata per rappresentare i nodi dell’albero contiene:</p>

<ol>
<li> Colore del nodo <code>bool color</code></li>
<li> Puntatore alla radice <code>struct RBTree * head</code></li>
<li> Puntatore al nodo padre <code>struct RBTree * p</code></li>
<li> Puntatore al nodo destro <code>struct RBTree * r</code></li>
<li> Puntatore al nodo sinistro <code>struct RBTree * l</code></li>
<li> Puntatore al record o alla tabella <code>void * nodeValue</code></li>
<li> Puntatore a puntatori di record <code>NodeRecord* allValues;</code></li>
<li> Numero di nodi con la stessa chiave <code>int occurrences;</code></li>
</ol>

<h3 id="toc_19">3.2.3 Uso</h3>

<p>La struct Database è un RBT contenente le tabelle caricate in memoria. Ogni tabella ha un vettore di RBT in cui ci sono salvati gli indirizzi dei record in base al suo indice, ovvero in base a ogni colonna. Nel caso in cui più nodi abbiano la stessa chiave, il campo occurrences viene incrementato e vengono salvati nell'array dinamico di puntatori a record. Si ricorda che questo può accadere solo per i record, in quanto le tabelle devono avere nomi univoci.</p>

<h2 id="toc_20">3.3 Heap con Update Dinamico</h2>

<p>L’Heap è stato modificato, aggiungendo la possibilità di fare Update Dinamici in tempo logaritmico, ispirandosi al paper redatto da O. Tamir, A. Morrison e N. Rinetzky [1], osservando in particolare la sezione numero 3: “A Sequential Heap with Mutable Priorities”.</p>

<h2 id="toc_21" style="
    margin-top: 100px;
">3.4 Strutture</h2>

<h3 id="toc_22">3.4.1 Struttura TableDB</h3>

<p>La struttura tabella (<code>struct TableDB</code>) contiene:</p>

<ol>
<li> Il nome della tabella <code>char * name</code></li>
<li> I nomi delle colonne <code>char ** columns</code></li>
<li> Il numero delle colonne <code>int nColumns</code></li>
<li> La lista di record <code>struct Record * recordList</code></li>
<li> L’array degli RBT <code>struct RBTree* treeList</code></li>
</ol>

<p>L’array degli RBT contiene tanti RBT quante sono le colonne della tabella, e ognuno di questi mantiene i record ordinati per quel campo.</p>

<h3 id="toc_23">3.4.2 Struttura ParseResult</h3>

<p><code>struct ParseResult</code> ha un campo per ogni possibile informazione di cui può essere necessario fare il parse e un campo di controllo (<code>bool success</code>) che indica se esso è andato a buon fine o meno.</p>

<h3 id="toc_24">3.4.3 Struttura QueryResultElement</h3>

<p><code>struct QueryResultElement</code> è una struttura che serve a contenere il risultato delle query. È una semplice linked list, in cui il campo “occurrence” viene utilizzato nelle query “group by” per memorizzare le occorrenze del valore e il campo “nodeValue” punta al record a cui si vuol riferire questo nodo della lista.</p>

<hr>

<h1 id="toc_25" style="
    margin-top:  600px;
">4. Corpo centrale</h1>

<p>Il corpo centrale è diviso in tre parti principali:</p>

<ol>
<li> Parse della query</li>
<li> Recupero della tabella</li>
<li> Esecuzione della query</li>
</ol>

<p>A cui si aggiungono tre fasi minori:</p>

<ul>
<li>  Inizializzazione del database</li>
<li>  Controllo query <em>(tra parsing ed esecuzione della query)</em></li>
<li>  Deallocazione della memoria <em>(dopo aver eseguito la query)</em></li>
</ul>

<h2 id="toc_26">4.1 Inizializzazione</h2>

<p>Viene inizializzata la struttura che conterrà il database e l’heap per la gestione della memoria.
Viene eseguita solo una volta, alla prima chiamata della funzione “executeQuery” e poi viene saltata.</p>

<h2 id="toc_27">4.2 Parsing</h2>

<p>Il parsing viene gestito dalla funzione <code>parseQuery()</code>, che ritorna una <code>struct ParseResult</code> con tutte le informazioni contenute nella query.
In caso quest'ultima fosse malformata, l'esecuzione viene interrotta e la proprietà <code>success</code> del <code>ParseResult</code> avrà valore <code>false</code>.</p>

<h2 id="toc_28">4.3 Recupero della tabella</h2>

<p>La tabella richiesta dalla query viene cercata in RAM dalla funzione <code>searchTableDb()</code>. Se la ricerca ha esito positivo, viene aggiornata la chiave associata alla tabella nella coda di priorità per la gestione della memoria.
In caso di esito negativo, la tabella viene caricata da disco tramite <code>loadTableFromFile()</code>.
Alla fine della fase di recupero della tabella, si ottiene una <code>struct Table</code> contenente l'esito dell'operazione e, in caso sia positivo, la tabella.</p>

<h2 id="toc_29">4.4 Esecuzione Query</h2>

<p>Viene eseguita la query.</p>

<h3 id="toc_30">4.4.1 Controllo della query</h3>

<p>Ora che si hanno tutte le informazioni, si procede a un check della validità delle informazioni richieste dalla query.</p>

<blockquote>
<p>E.g.: Le colonne richieste esistono.</p>
</blockquote>

<h3 id="toc_31" style="
    margin-top:  100px;
">4.4.2 Create Table</h3>

<p>Una query <code>CREATE TABLE</code> valida prevede che non venga caricata nessuna tabella.
Viene generato il file su disco e caricato in memoria tramite la stessa procedura applicata alle altre tabelle.</p>

<h3 id="toc_32">4.4.3 Insert Into</h3>

<p>Il record specificato viene aggiunto prima nel file su disco, poi nelle strutture in memoria.</p>

<h3 id="toc_33">4.4.4 Selezione</h3>

<p>Attraverso la funzione <code>querySelect()</code> viene creata una <code>struct QueryResultList</code>, che contiene il risultato della query. Il contenuto viene loggato tramite una chiamata a <code>generateLog()</code> e la struttura deallocata.</p>

<h2 id="toc_34">4.5 Deallocazione della memoria</h2>

<p>Al termine dell'esecuzione vengono eliminate le strutture superflue, in questo caso la <code>struct ParseResult</code>.</p>

<h1 id="toc_35" style="
    margin-top:  600px;
">5. Parser</h1>

<p>Il parser deve gestire un numero limitato di possibili query, ha quindi una struttura molto semplice.
Tutta l'operazione di parsing viene eseguita in tempo lineare rispetto alla lunghezza della query.</p>

<p>L'entry point del parser è la funzione: </p>

<div><div class="prism-show-language"><div class="prism-show-language-label">C</div></div><pre class=" language-c"><code class=" language-c">ParseResult parseQuery <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> query<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>

<p>Durante l'esecuzione viene usato direttamente un puntatore <code>char *</code>, che segue il progresso del parsing.
Il parser restituisce un puntatore alla <code>struct ParseResult</code>, così composta: </p>

<div><div class="prism-show-language"><div class="prism-show-language-label">C</div></div><pre class=" language-c"><code class=" language-c"><span class="token keyword">struct</span> ParseResult <span class="token punctuation">{</span>
    bool success<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span> tableName<span class="token punctuation">;</span>
    <span class="token keyword">int</span> queryType<span class="token punctuation">;</span>
    <span class="token keyword">int</span> querySelector<span class="token punctuation">;</span>
    <span class="token keyword">int</span> nColumns<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span> columns<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span> fieldValues<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span> keyName<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span> key<span class="token punctuation">;</span>
    <span class="token keyword">int</span> order<span class="token punctuation">;</span>
    <span class="token keyword">int</span> parseErrorCode<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>

<p>dove:</p>

<ol>
<li><p><code>bool success</code>: contiene l'esito dell'analisi.</p></li>
<li><p><code>char * tableName</code>: contiene il nome della tabella su cui agisce la query</p></li>
<li><p><code>int queryType</code>: contiene il codice numerico identificativo del tipo di query, tra i possibili seguenti:</p>

<ul>
<li>Create Table: <code>-1</code></li>
<li>Select con filtro Where: <code>0</code></li>
<li>Select con filtro Order By: <code>1</code></li>
<li>Select con filtro Group By: <code>2</code></li>
<li>Insert Into: <code>3</code></li>
<li>Select senza filtri: <code>4</code></li>
<li>No Query: <code>6</code></li>
</ul></li>
<li><p><code>char ** columns</code>: contiene i puntatori di tipo <code>char *</code> ai nomi delle colonne interessate dalla query.</p></li>
<li><p><code>int nColumns</code>: contiene il numero di colonne interessate dalla query, che corrisponde al numero di puntatori presenti nel campo <code>char ** columns</code>.</p></li>
<li><p><code>char ** fieldValues</code>: usata solo nelle query di tipo Insert Into. Contiene <code>nColumns</code> puntatori di tipo <code>char *</code> alle stringhe contenenti i valori da inserire.</p></li>
<li><p><code>int querySelector</code>: usato solo in query di tipo Select con filtro Where, contiene il codice numerico identificativo dell'operatore:</p>

<ul>
<li>Equal: <code>0</code></li>
<li>Greater: <code>1</code></li>
<li>Lesser: <code>2</code></li>
<li>Greater Equal: <code>3</code></li>
<li>Lesser Equal: <code>4</code></li>
<li>No Operator: <code>5</code></li>
</ul></li>
<li><p><code>char * keyName</code>: usato nelle query di tipo:</p>

<ul>
<li>Select con filtro Where, per contenere il nome del campo interessato dalla condizione where.</li>
<li>Select con filtro Group By, per contenere il nome del campo per cui raggruppare i record.</li>
<li>Select con filtro Order By, per contenere il nome del campo per cui ordinare i record.</li>
</ul></li>
<li><p><code>char * key</code>: usato solo nella query di tipo Select con filtro Where, per contenere il valore da paragonare quando si controlla la condizione.</p></li>
<li><p><code>int order</code>: usato solo nelle query di tipo Select con filtro Order By, contiene l'ordine desiderato. Può assumere i valori:</p>

<ul>
<li><code>ASC</code>: 0</li>
<li><code>DESC</code>: 1</li>
</ul></li>
<li><p><code>int parseErrorCode</code>: contiene un identificativo numerico hardcoded nel sorgente, unico al punto in cui il parse ha fallito l'esecuzione e terminato prematuramente. Controllando il codice si può facilmente risalire al punto in cui si è manifestato il problema. I codici di errore sono suddivisi in classi:</p>

<ul>
<li><code>0-99</code>: Errori Generali</li>
<li><code>101-199</code>: Errori durante il parsing di una query "Create Table"</li>
<li><code>201-299</code>: Errori durante il parsing di una query "Insert Into"</li>
<li><code>301-399</code>: Errori durante il parsing della parte senza filtri di una query "Select"</li>
<li><code>401-499</code>: Errori durante il parsing della parte finale di una query "Select Where"</li>
<li><code>501-599</code>: Errori durante il parsing della parte finale di una query "Select Group By"</li>
<li><code>601-699</code>: Errori durante il parsing della parte finale di una query "Select Order By"</li>
</ul></li>
</ol>

<hr>

<h1 id="toc_36" style="
    margin-top:  300px;
">6 Costi Computazionali</h1>

<p>I costi di caricamento ed eliminazione di una tabella dalla RAM sono considerati separatamente in quanto non sempre vengono eseguiti: per ottenere il calcolo del costo nel caso di una query su una tabella non ancora presente in RAM, sarà necessario aggiungere il costo del caricamento al costo della query. L'eliminazione di una tabella è un operazione che si verifica solo nel caso in cui le tabelle siano più di una e in contemporanea la memoria occupata dalle tabelle superi quella consentita dalla threshold.</p>

<p>Si evita di considerare il tempo impiegato per fare il parse della query, in quanto per forza lineare rispetto alla lunghezza dell'input e di poco interesse al fine dell'analisi.</p>

<p>Nelle query di tipo Create Table e Insert Into, il costo di scrittura su disco delle informazioni è lineare rispetto alla lunghezza della query. Abbiamo preferito tralasciarlo nell'analisi dei costi in quanto è fisso.</p>

<p>Nelle espressioni di complessità vengono usati i seguenti simboli:</p>

<div><pre class=" language-none"><code class=" language-none">X = numero delle tabelle caricate in memoria;
Y = numero dei record nella tabella corrente;
Z = numero di colonne nella tabella corrente.</code></pre></div>

<h2 id="toc_37">6.1 CREATE TABLE</h2>

<p>Per creare una tabella è necessario inserirla nel database, ovvero aggiungere un nodo al Red-Black Tree che gestisce le tabelle presenti in memoria. Il tempo dell'operazione e' logaritmico rispetto al numero di tabelle già caricate in memoria e la memoria è costante.</p>

<ul>
<li>Tempo: <code>O(log(X))</code></li>
<li>Spazio: <code>Θ(1)</code></li>
</ul>

<h2 id="toc_38">6.2 INSERT INTO</h2>

<p>Per inserire un elemento in una tabella è necessario: cercare la tabella nel RBT [<code>O(log(x))</code>], inserire il nuovo record nella linked list di record [<code>Θ(1)</code>] e aggiungere il suo puntatore in tutti i RBT che indicizzano le colonne. In ogni albero il tempo di inserzione è logaritmico in base al numero di record, e va ripetuto per Z alberi dando <code>O(Z * log(Y))</code>. </p>

<p>Il costo in termini di spazio e' il nuovo record nella lista [<code>O(1)</code>] e un puntatore al record per ogni colonna <code>[O(Z)]</code>.</p>

<ul>
<li>Tempo: <code>O(log(X)) + O(Z * log(Y))</code></li>
<li>Spazio: <code>Θ(Z)</code></li>
</ul>

<h2 id="toc_39" style="
    margin-top:  200px;
">6.3 SELECT</h2>

<p>Ogni query "Select" restituisce, in tempo lineare, una linked list <code>queryResultList</code> di puntatori ai record nell'ordine richiesto.
Questo approccio abbassa il tempo a discapito di un consumo maggiore di memoria, che passa da costante (controllare solo i dati) a lineare (creare la lista di <code>Y</code> puntatori. </p>

<h3 id="toc_40">6.3.1 SENZA FILTRI</h3>

<p>Il costo computazionale della select senza filtri e' quello della ricerca della tabella (logaritmico rispetto al numero di tabelle), più la visita della lista di record con la creazione della lista di puntatori (lineare rispetto ai record) e la stampa (anch'essa lineare rispetto ai record).</p>

<ul>
<li>Tempo: <code>O(log(X)) + Θ(Y)</code></li>
<li>Spazio: <code>Θ(Y)</code></li>
</ul>

<h3 id="toc_41">6.3.2 ORDER BY</h3>

<p>Il costo computazionale della select order by è il costo della ricerca della tabella (logaritmico rispetto al numero di tabelle), più il costo della ricerca del RBT associato alla colonna richiesta (lineare rispetto al numero di colonne presenti nella tabella), e la creazione della lista ordinata di puntatori durante la visita completa (lineare rispetto al numero di record).</p>

<ul>
<li>Tempo: <code>O(log(X)) + O(Z) + Θ(Y)</code></li>
<li>Spazio: <code>Θ(Y)</code></li>
</ul>

<h3 id="toc_42">6.3.3 GROUP BY</h3>

<p>L'esecuzione della query Group By esegue una query Order By e raggruppa gli elementi in tempo lineare. Il costo computazionale è identico.</p>

<ul>
<li>Tempo: <code>O(log(X)) + O(Z) + Θ(Y)</code></li>
<li>Spazio: <code>Θ(Y)</code></li>
</ul>

<h3 id="toc_43">6.3.4 WHERE</h3>

<p>Il costo computazionale è quello della ricerca della tabella (logaritmico rispetto al numero di tabelle), più quello del controllo della condizione su ogni elemento (lineare sul numero di elementi) e la creazione della lista di puntatori (lineare sul numero di elementi).</p>

<ul>
<li>Tempo: <code>O(log(X)) + O(Y)</code></li>
<li>Spazio: <code>Θ(numero di nodi che soddisfano la select)</code></li>
</ul>

<h4 id="toc_44">6.3.4.1 WHERE PUNTUALE (==)</h4>

<p>Nel solo caso della SELECT WHERE puntuale l'operazione ha costo computazionale differente, grazie al raggruppamento di piu record nello stesso albero del RBT.</p>

<ul>
<li>Tempo: <code>O(log(X)) + O(log(Y)) + Θ(numero di nodi che soddisfano la select)</code></li>
</ul>

<h2 id="toc_45">6.4 Caricamento ed eliminazione tabelle dalla RAM</h2>

<h3 id="toc_46">6.4.1 Caricamento di una tabella da file</h3>

<p>Il caricamento prevede la creazione della tabella, più l'inserimento dei record. Il costo è fondamentalmente quello di una query Create Table, seguito da <code>Z</code> Insert Into.</p>

<ul>
<li>Tempo: <code>O(log(X)) + O((Z * log(Y)) Y)</code></li>
<li>Spazio: <code>Θ(Z * Y)</code></li>
</ul>

<h3 id="toc_47">6.4.2 Eliminazione di una tabella dalla memoria</h3>

<p>Per eliminare una tabella dalla memoria la si deve trovare nell'albero del database (tempo logaritmico rispetto al numero di tabelle), eliminare tutti i record della lista (tempo lineare rispetto al numero di record) e eliminare tutti i nodi degli alberi relativi agli indici (tempo lineare rispetto al numero di record). Quindi:</p>

<ul>
<li>Tempo: <code>O(log(X)) + Θ(Y * Z)</code></li>
<li>Spazio: <code>Θ(1)</code></li>
</ul>

<hr>

<h3 id="toc_48" style="
    margin-top: 150px;
">7 Riferimenti esterni:</h3>

<p>[1] <a href="https://www.cs.tau.ac.il/~mad/publications/opodis2015-heap.pdf"><em>A Heap-Based Concurrent Priority Queue with Mutable Priorities for Faster Parallel Algorithms</em></a>, by O. Tamir, A. Morrison e N. Rinetzky.</p>



<script type="text/javascript">
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(\w+)\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e){var t=n.util.type(e);switch(t){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=n.util.clone(e[r]));return a;case"Array":return e.map&&e.map(function(e){return n.util.clone(e)})}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&&(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in a)a.hasOwnProperty(i)&&(o[i]=a[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,t,a,r){r=r||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],a||l),"Object"!==n.util.type(e[l])||r[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||r[n.util.objId(e[l])]||(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,r)):(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,r)))}},plugins:{},highlightAll:function(e,t){var a={callback:t,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var r,l=a.elements||document.querySelectorAll(a.selector),i=0;r=l[i++];)n.highlightElement(r,e===!0,a.callback)},highlightElement:function(t,a,r){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1],i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(!s||!i)return n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),a&&_self.Worker){var c=new Worker(n.filename);c.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,r){var l=n.tokenize(e,t);return a.stringify(n.util.encode(l),r)},tokenize:function(e,t){var a=n.Token,r=[e],l=t.rest;if(l){for(var i in l)t[i]=l[i];delete t.rest}e:for(var i in t)if(t.hasOwnProperty(i)&&t[i]){var o=t[i];o="Array"===n.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],c=u.inside,g=!!u.lookbehind,h=!!u.greedy,f=0,d=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var m=r[p];if(r.length>e.length)break e;if(!(m instanceof a)){u.lastIndex=0;var y=u.exec(m),v=1;if(!y&&h&&p!=r.length-1){var b=r[p+1].matchedStr||r[p+1],k=m+b;if(p<r.length-2&&(k+=r[p+2].matchedStr||r[p+2]),u.lastIndex=0,y=u.exec(k),!y)continue;var w=y.index+(g?y[1].length:0);if(w>=m.length)continue;var _=y.index+y[0].length,P=m.length+b.length;if(v=3,P>=_){if(r[p+1].greedy)continue;v=2,k=k.slice(0,P)}m=k}if(y){g&&(f=y[1].length);var w=y.index+f,y=y[0].slice(f),_=w+y.length,S=m.slice(0,w),O=m.slice(_),j=[p,v];S&&j.push(S);var A=new a(i,c?n.tokenize(y,c):y,d,y,h);j.push(A),O&&j.push(O),Array.prototype.splice.apply(r,j)}}}}}return r},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.matchedStr=a||null,this.greedy=!!r};if(a.stringify=function(e,t,r){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join("");var l={type:e.type,content:a.stringify(e.content,t,r),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:r};if("comment"==l.type&&(l.attributes.spellcheck="true"),e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o="";for(var s in l.attributes)o+=(o?" ":"")+s+'="'+(l.attributes[s]||"")+'"';return"<"+l.tag+' class="'+l.classes.join(" ")+'" '+o+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,l=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return r&&(n.filename=r.src,document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",n.highlightAll)),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
</script>

<script type="text/javascript">
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:{pattern:/(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(true|false)\b/,"function":/[a-z0-9_]+(?=\()/i,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
</script>

<script type="text/javascript">
Prism.languages.c=Prism.languages.extend("clike",{keyword:/\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,operator:/\-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*\/]/,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)[ful]*\b/i}),Prism.languages.insertBefore("c","string",{macro:{pattern:/(^\s*)#\s*[a-z]+([^\r\n\\]|\\.|\\(?:\r\n?|\n))*/im,lookbehind:!0,alias:"property",inside:{string:{pattern:/(#\s*include\s*)(<.+?>|("|')(\\?.)+?\3)/,lookbehind:!0},directive:{pattern:/(#\s*)\b(define|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/,lookbehind:!0,alias:"keyword"}}},constant:/\b(__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|stdin|stdout|stderr)\b/}),delete Prism.languages.c["class-name"],delete Prism.languages.c["boolean"];
</script>

<script type="text/javascript">
!function(){if("undefined"!=typeof self&&self.Prism&&self.document){var e={html:"HTML",xml:"XML",svg:"SVG",mathml:"MathML",css:"CSS",clike:"C-like",javascript:"JavaScript",abap:"ABAP",actionscript:"ActionScript",apacheconf:"Apache Configuration",apl:"APL",applescript:"AppleScript",asciidoc:"AsciiDoc",aspnet:"ASP.NET (C#)",autoit:"AutoIt",autohotkey:"AutoHotkey",basic:"BASIC",csharp:"C#",cpp:"C++",coffeescript:"CoffeeScript","css-extras":"CSS Extras",fsharp:"F#",glsl:"GLSL",http:"HTTP",inform7:"Inform 7",json:"JSON",latex:"LaTeX",lolcode:"LOLCODE",matlab:"MATLAB",mel:"MEL",nasm:"NASM",nginx:"nginx",nsis:"NSIS",objectivec:"Objective-C",ocaml:"OCaml",parigp:"PARI/GP",php:"PHP","php-extras":"PHP Extras",powershell:"PowerShell",jsx:"React JSX",rest:"reST (reStructuredText)",sas:"SAS",sass:"Sass (Sass)",scss:"Sass (Scss)",sql:"SQL",typescript:"TypeScript",vhdl:"VHDL",vim:"vim",wiki:"Wiki markup",yaml:"YAML"};Prism.hooks.add("before-highlight",function(s){var a=s.element.parentNode;if(a&&/pre/i.test(a.nodeName)){var t,i,r=a.getAttribute("data-language")||e[s.language]||s.language.substring(0,1).toUpperCase()+s.language.substring(1),l=a.previousSibling;l&&/\s*\bprism-show-language\b\s*/.test(l.className)&&l.firstChild&&/\s*\bprism-show-language-label\b\s*/.test(l.firstChild.className)?i=l.firstChild:(t=document.createElement("div"),i=document.createElement("div"),i.className="prism-show-language-label",t.className="prism-show-language",t.appendChild(i),a.parentNode.insertBefore(t,a)),i.innerHTML=r}})}}();
</script>





</body></html>